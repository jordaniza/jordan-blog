---
title: Fallback
description: The first challenge in Ethernaut, Fallback, is a great introduction to the EVM and how to write calls in Yul/Assembly
index: 1
---

## Topics Covered:

- Setting up our first foundry test
- Intro to mload and sload
- Making contract calls in assembly

This is a long one, and we are going to cover a lot of ground, so buckle up. By the end though, you should have a working, replicable foundry setup, and have covered the basics of making calls to other contracts using Yul.

## Getting foundry setup

Before we start, let's lay a foundation for how we are going to structure these tests, we are targeting the `Fallout` contract in Ethernaut, hence our project structure should look like this:

```sh
lib/                          # dependencies
src/
  |-- Fallback.sol            # target contract
test/
  |-- Fallback.t.sol          # attack contract
foundry.toml                  # foundry config
```

### Fallback.sol:

The first contract in Ethernaut is a relatively simple starting point, copy this code into the `Fallback.sol` file in the `src` folder:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Fallback {
    mapping(address => uint256) public contributions;
    address public owner;

    constructor() {
        owner = msg.sender;
        contributions[msg.sender] = 1000 * (1 ether);
    }

    modifier onlyOwner() {
        require(msg.sender == owner, "caller is not the owner");
        _;
    }

    function contribute() public payable {
        require(msg.value < 0.001 ether);
        contributions[msg.sender] += msg.value;
        if (contributions[msg.sender] > contributions[owner]) {
            owner = msg.sender;
        }
    }

    function getContribution() public view returns (uint256) {
        return contributions[msg.sender];
    }

    function withdraw() public onlyOwner {
        payable(owner).transfer(address(this).balance);
    }

    receive() external payable {
        require(msg.value > 0 && contributions[msg.sender] > 0);
        owner = msg.sender;
    }
}
```

### Fallback.t.sol

Our `Fallback.t.sol` will have the following structure:

```solidity
pragma solidity ^0.8.0;

// import the forge test utilities
import "forge-std/Test.sol";

// import our target contract
import "../src/Fallback.sol";

// ensure our test contract has the forge test utils enabled
contract ASMFallback is Test {

    // here we will declare any state variables

    function setUp() public {
        // this function runs before each of our test
        // functions, and is where we will set up
        // our contract and state
    }

    function testAttackFallback() public {
        // this is where our attack will go
        // forge tests must always start with the word
        // 'test' and be marked as `public` or `external`
    }
}
```

Let's fill this in: first let's define 2 state variables:

1. Our `target` contract, which is of type `Fallout`
2. Our `attacker` which is a nominal address

```solidity
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "../src/Fallback.sol";

contract ASMFallback is Test {
    Fallback public target;
    address payable public attacker = payable(address(420));

    // ...
}

```

Now, let's create our `setUp` hook, recall the aim of this challenge:

> You will beat this level if:
>
> You claim ownership of the contract
>
> You reduce its balance to 0

So we need to make sure the target is deployed and has some ether.
For good measure, let's also give the attacker some ether.

We can use foundry's `vm.deal(address who, uint256 wei)` to mint arbitrary amounts of wei to any address:

```solidity
function setUp() public {
    target = new Fallback();
    vm.deal(attacker, 1 ether);
    vm.deal(address(target), 1000 ether);
}
```

Lastly, we want to execute our test as the attacker. We can do this using foundry's `vm.startPrank(address who)` which will execute all subsequent functions as the address `who`.

```solidity
function testAttackFallback() public attack {
  vm.startPrank(attacker);

  // our exploit goes here

  vm.stopPrank();
}
```

Personal preference here, but this pattern is so common I like to mark the attack function as such with a modifier:

```solidity
modifier attack() {
    vm.startPrank(attacker);
    _;
    vm.stopPrank();
}

function testAttackFallback() public attack {
    // our exploit goes here
}
```

Finally, set's complete the setup by defining our assertions: what must hold true for this challenge to be considered "Complete"?

```solidity
function testAttackFallback() public attack {
  // ... exploit
  // you claim ownership of the contract
  assertEq(target.owner(), attacker);
  // you reduce its balance to 0
  assertEq(address(target).balance, 0);
}

```

With that, we are good to go, putting it all together:

```solidity
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "../src/Fallback.sol";

contract ASMFallback is Test {
    Fallback public target;
    address payable public attacker = payable(address(420));

    function setUp() public {
        target = new Fallback();
        vm.deal(attacker, 1 ether);
        vm.deal(address(target), 1000 ether);
    }

    modifier attack() {
        vm.startPrank(attacker);
        _;
        vm.stopPrank();
    }

    function testAttackFallback() public attack {
        // assertions
        assertEq(target.owner(), attacker);
        assertEq(address(target).balance, 0);
    }
}
```

## The Exploit

The exploit here is reasonably straightforward. Take a second and see if you can spot it...

We're trying to become the `owner` so we can see that the owner is set in 3 places:

1. The constructor (we can discard this)
2. The contribute function
3. The fallback function

So we know that we will need to call some combination of the contribute and fallback function to become owner, after which point we can just withdraw the contract balance.

## Our first line of assembly

We're now ready to start writing yul. This exploit requires contract calls, so let's first see how do we make a low level call.

When speaking about the EVM, we are going to be making a call and need to determine a few things:

- The address to call
- The data to send to in the call, comprised of:
  - The function signature
  - The calldata
- The amount of gas to send
- Any wei to send with the call
- Any expected return data

### Fetching the address

Our address would be `address(target)` in solidity. However if we try and do this in Yul, it wont compile.

Instead we have to think in terms of how Yul thinks. Some core principles:

1. Declare inline assembly by using `assembly {}`
2. Variables can be declared inside assembly blocks using

```solidity
assembly {
  let variable := 1 // note we do not need semicolons in assembly
}
```

3. You can also declare variables outside of assembly blocks, and assign them inside such blocks.

_Be careful with this: there are no such thing as types inside assembly, in general a bytes32 type is a reasonably safe representation of the assembly variable._

Recall that we have defined our target in the contract state variables:

```solidity
contract ASMFallback is Test {
    Fallback public target;
```

This means that `target` is stored in the contract storage, in one of the storage `slots`. You might look at that and think "cool slot zero", but the fact we are inheriting from `Test` makes that a bit challenging to determine.

Fortunately, we have a special assembly property for this:

```solidity
assembly {
  // fetch the target address by loading the data stored at the storage slot of target
  // the variables are not written to memory automatically
  // but stored on the stack, then the compiler make it available when we need it
  let targetAddress  := sload(target.slot)
}
```

Let's do a quick log to see that this has worked correctly:

```solidity
// add this to our contract
function testFetchAddress() public view {
  bytes32 fetchedAddress;
  assembly {
    fetchedAddress := sload(target.slot)
  }
  console2.log("Fetched from assembly");
  console2.logBytes32(fetchedAddress);

  console2.log("Fetched from solidity");
  console2.log(address(target));
}
```

Now let's run it with the following command:

```sh
forge test --match-test testFetchAddress -vvvvv
```

Here is output:

```
Running 1 test for test/Fallback.t.sol:ASMFallback
[PASS] testFetchAddress() (gas: 7028)
Logs:
  Fetched from assembly
  0x0000000000000000000000005615deb798bb3e4dfa0139dfa1b3d433cc23b72f
  Fetched from solidity
  0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f
```
